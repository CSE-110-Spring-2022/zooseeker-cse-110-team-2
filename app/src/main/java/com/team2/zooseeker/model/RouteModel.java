package com.team2.zooseeker.model;

import android.content.Context;
import android.util.Log;

import org.jgrapht.Graph;
import org.jgrapht.GraphPath;
import org.jgrapht.alg.shortestpath.DijkstraShortestPath;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Map;

import cse110.IdentifiedWeightedEdge;
import cse110.ZooData;

public class RouteModel {
    ArrayList<String> list;
    InputStream fileIn;
    Graph<String, IdentifiedWeightedEdge> graph;
    Map<String, ZooData.VertexInfo> vertexInfo;
    Map<String, ZooData.EdgeInfo> edgeInfo;

    public RouteModel(ArrayList<String> list, InputStream fileIn) {
        this.list = new ArrayList<>(list);
        this.fileIn = fileIn;
        graph = ZooData.loadZooGraphJSON(fileIn);
    }

    public RouteModel(InputStream fileIn) {
        this.list = new ArrayList<>();
        this.fileIn = fileIn;
        graph = ZooData.loadZooGraphJSON(fileIn);
    }

    public RouteModel(Graph<String, IdentifiedWeightedEdge> graph, Map<String, ZooData.VertexInfo> vertexInfo, Map<String, ZooData.EdgeInfo> edgeInfo) {
        this.list = new ArrayList<>();
        this.fileIn = null;
        this.graph = graph;
        this.vertexInfo = vertexInfo;
        this.edgeInfo = edgeInfo;
    }

    public void setExhibits(ArrayList<String> exhibitsList) {
        this.list = exhibitsList;
    }


    public ArrayList<String> genRoute() {
        // "source" and "sink" are graph terms for the start and end
        String entrance_exit = "entrance_exit_gate";
        String prev = entrance_exit;
        ArrayList<String> route = new ArrayList<>();
        route.add(entrance_exit);
        while (!list.isEmpty()) {
            String closest = "";
            int closestDist = Integer.MAX_VALUE;
            for (String next : list) {
                GraphPath<String, IdentifiedWeightedEdge> path = DijkstraShortestPath.findPathBetween(graph, prev, next);
                int pathDist = path.getLength();

                //System.out.printf("From %s to %s: %d\n", prev, next, pathDist);
                if (pathDist < closestDist) {

                    closest = next;
                    closestDist = pathDist;
                }
//                Log.d("DEBUG PATH", path.toString());
            }
            list.remove(closest);
            route.add(closest);
            prev = closest;
        }
        route.add(entrance_exit);
        return route;
    }

    /**
     * Generate list of directions based on routes generated by genRoute()
     * @param route
     * @return
     */
    public ArrayList<String> getDirections(ArrayList<String> route) {
        ArrayList<String> directions = new ArrayList<>();
        for (int i = 0; i < route.size() - 1; i++) {
            String edgeStartVertex = route.get(i);
            String edgeEndVertex = route.get(i + 1);
            ArrayList<String> path = getDirections(edgeStartVertex, edgeEndVertex);
            directions.addAll(path);
        }
        if (directions.size() > 0) {
            directions.set(0, "Proceed " + directions.get(0).substring(9));
            for (int i = 0; i < directions.size(); i++) {
                directions.set(i, (i + 1) + ". " + directions.get(i));
            }
        }
        return directions;
    }

    public ArrayList<String> getDirections(String start, String end) {
        ArrayList<String> directions = new ArrayList<>();
        GraphPath<String, IdentifiedWeightedEdge> path = DijkstraShortestPath.findPathBetween(graph, start, end);
        String startVertex = path.getStartVertex();
        for (IdentifiedWeightedEdge e : path.getEdgeList()) {
            String edge = "";
            if (startVertex.equals(vertexInfo.get(graph.getEdgeSource(e).toString()).id)) {
                edge = formatEdge(e) + vertexInfo.get(graph.getEdgeTarget(e).toString()).name;
                startVertex = vertexInfo.get(graph.getEdgeTarget(e).toString()).id;
            } else {
                edge = formatEdge(e) + vertexInfo.get(graph.getEdgeSource(e).toString()).name;
                startVertex = vertexInfo.get(graph.getEdgeSource(e).toString()).id;
            }
            directions.add(edge);
        }
        return directions;
    }

    public String formatEdge(IdentifiedWeightedEdge e) {
        return "Continue on " +  edgeInfo.get(e.getId()).street + " " + (int) graph.getEdgeWeight(e) + " ft towards ";
    }




}
